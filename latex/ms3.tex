\documentclass[a4paper,11pt,listof=numbered,glossary=totoc,parskip=half,toc=bib]{scrreprt}
\usepackage[a4paper,left=2cm,right=2cm,top=2cm,bottom=2cm]{geometry}
\usepackage[onehalfspacing]{setspace}


\usepackage[colorlinks,
pdfpagelabels,
pdfstartview = FitH,
bookmarksopen = true,
bookmarksnumbered = true,
linkcolor = black,
plainpages = false,
hypertexnames = false,
citecolor = black]{hyperref}

\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage[ngerman]{babel}
\usepackage{graphicx}
\usepackage{caption}
\usepackage[automake,toc,section=chapter,numberedsection]{glossaries}
\usepackage{uarial}
\usepackage{tabularx}
\usepackage{booktabs}
\usepackage{multirow}
\usepackage{icomma} % Damit im Mathemodus nach einem Komma kein Leerzeichen gesetzt wird
\usepackage[cache=false]{minted}
\renewcommand{\listoflistingscaption}{Verzeichnis der Code-Listings}
\usepackage[table]{xcolor} % Zum Ändern der Farben in Tabellen
\usepackage{xspace}

\usepackage{csquotes}
\usepackage[backend=biber, style=apa]{biblatex}
\addbibresource{quellen.bib}

\renewcommand{\familydefault}{\sfdefault}
\newcommand{\zB}{\mbox{z.\,B.}\xspace}
\newcommand{\dash}{\mbox{d.\,h.}\xspace}

\RedeclareSectionCommand[
beforeskip = 3pt,
afterskip = 3pt]{subsection} %vor subsection 6pt und nach subsection 6pt Abstand
\RedeclareSectionCommand[
beforeskip = 1pt,
afterskip = 1pt]{subsubsection} %vor subsection 6pt und nach subsection 6pt Abstand


% Glossar
\makeglossary
\newglossaryentry{re}
{
	name={Requirements Engineering (RE)},
	description={Das \textit{Requirements Engineering} bezeichnet die Disziplin der Anforderungsermittlung. Damit ist typischerweise das Ermitteln, Dokumentieren, Prüfen und Abstimmen von funktionalen und nicht-funktionalen Anforderungen gemeint.}
}

\newglossaryentry{stakeholder}
{
	name={Stakeholder},
	description={\textit{Stakeholder} (dt. Anspruchsgruppen) sind alle Personen, die mit dem zu entwickelnden System konfrontiert sind.
Der Begriff beschränkt sich nicht nur auf diejenigen, die unmittelbar mit dem System arbeiten, sondern schließt insbesondere den Auftraggeber, das Entwicklerteam oder die mit dem Betrieb des Systems betrauten Personen mit ein.}
}
\newglossaryentry{userstory}
{
	name={User Story},
	description={Eine \textit{User Story} ist eine besonders in agilen Projekten weit verbreitete Dokumentationsform im Kontext der Anforderungsermittlung.
Sie besteht aus einem einfachen Satz, der eine Anforderung aus der Sicht einer definierten Stakeholder-Rolle beschreibt und entspricht immer einem fest vorgegebenen Format:
\textit{Als [Rolle] möchte ich / wünsche ich mir [Funktion], damit [Begründung].}
User Stories lassen sich damit auf einfache Karteikarten schreiben, die an ein Whiteboard gepinnt oder auf einem großen Tisch ausgebreitet werden können. Somit lassen sie sich gut in Workshops zur Visualisierung und Priorisierung der Anforderungen nutzen.}
}
\newglossaryentry{moscow}
{
	name={MoSCoW},
	description={Die \textit{MoSCoW-Methode} wird im vorliegenden Projekt genutzt, um Anforderungen zu priorisieren.
\textit{Must have (M)} legt fest, dass die betrachtete Anforderung zwingend umgesetzt werden muss.
\textit{Should have (S)} bedeutet, dass die Umsetzung wünschenswert, aber nicht kritisch ist.
\textit{Can have (C)} bezeichnet unkritische Anforderungen, die optional zu einem späteren Zeitpunkt implementiert werden können.
\textit{Won't have (W)} legt fest, dass die betrachtete Anforderung (aktuell) nicht umgesetzt wird.
Die Priorisierung von Anforderungen ist nicht endgültig, sondern kann im Projektverlauf angepasst werden.
	}
}
\newglossaryentry{git} 
{
	name={Git-Repository},
	description={GIT ist ein Werkzeug zur Versionskontrolle, dass vor allem zur kollaborativen Quellcode-Verwaltung in Software-Projekten eingesetzt wird, sich aber auch zur Verwaltung und Versionierung von Artefakten der Dokumentation eignet.
Die von Microsoft betriebene Plattform GitHub.com bietet einen Dienst für das Hosting von Git-Repositories.}
}
\newglossaryentry{responsive}
{
	name={Responsive Design},
	description={Ist eine Applikation so gestaltet, dass sie sich an verschiedene Bildschirmgrößen und -ausrichtungen, wie sie beispielsweise bei Smartphones-, Tablets oder Desktop-PCs zu finden sind, anpassen kann, so spricht man von \textit{Responsive Design}.
	}
}
\newglossaryentry{uml}
{
	name={UML},
	description={Die \textit{Unified Modeling Language} ist eine grafische Modellierungssprache zur Analyse, Implementation und zum Design von softwarebasierten Systemen sowie zur Beschreibung von Prozessen. \autocite{UML} Sie wird durch die \textit{Object Management Group} entwickelt. Die Sprache definiert jeweils sieben Struktur- und Verhaltensdiagramme.
	In diesem Bericht werden folgende Diagrammtypen genannt:
	\begin{itemize}
	\item cod:	Komponentendiagramm
	\item cld:	Klassendiagramm
	\item sm:	Zustandsdiagramm
	\item sqd:	Sequenzdiagramm
	\end{itemize}
	}
}
\newglossaryentry{bpmn}
{
	name={BPMN},
	description={Die \textit{Business Process Model and Notation} ist ein Standard zur grafischen Spezifikation von Geschäftsprozessen. \autocite{BPMN} 
	}
}
\newglossaryentry{erm}
{
	name={ERM},
	description={Ein \textit{Entity-Relationship-Model} ist ein Modell zur Darstellung von Entitäten und Beziehungen. Der Einsatz von ERM gilt als Standard bei der Datenmodellierung in der Softwareentwicklung.
	}
}
\newglossaryentry{gui}
{
	name={GUI},
	description={Grafische Benutzeroberfläche
	}
}

\subject{Meilensteinbericht}
\title{Meilenstein 3}
\subtitle{Dokumentationskonzept bereitgestellt}

\begin{document}
	\pagenumbering{Roman}
	\begin{titlepage}
		
		\centering
		\vspace*{2.5cm}
		{\large\bfseries Meilensteinbericht\par}	
		{\Huge\bfseries Meilenstein 3\par}
		{\Large\bfseries Dokumentationskonzept bereitgestellt\par}

		{\Large Projekt Q-Teams\par}
		{\large\today\par}
		\vspace{0.5cm}

			
		
		\includegraphics[scale=0.5]{iubh_logo}
		
		IUBH Fernstudium
		\vspace{0.5cm}
		
		\begin{tabular}{lllrl}
			\toprule
			\textbf{Gruppe} & \textbf{Nachname} & \textbf{Vorname} & \textbf{Matrikelnr.} & \textbf{Studiengang} \\
			\midrule
			Projektleiter & Sawatzki & Jörg & 9186524 & BSc. Informatik \\
			Mitglied 2 & Hahn & Maximilian & 91710055 & BSc. Wirtschaftsinformatik \\
			Mitglied 3 & Lapenat & Holger & 3191237 & BSc. Wirtschaftsinformatik \\
			Mitglied 4 & Moch & Daniel & 91710824 & BSc. Wirtschaftsinformatik \\
			\bottomrule
		\end{tabular}	
	\end{titlepage}
	
	
	\newpage
	\setcounter{tocdepth}{2}
	\tableofcontents
	
	\newpage
	\pagenumbering{arabic}	
	\chapter{Beschreibung der Projektdokumente}

	Im Verlauf des Projektes werden verschiedene Dokumente erstellt und gepflegt. Diese unterstützen das Projektmanagement oder informieren Stakeholder über den Status bestimmter Aspekte des Projekts.
	
	Der Aufbau des Risikoregisters ist bereits im Bericht zu Meilenstein 1 festgelegt worden. Die weiteren Dokumente werden im Folgenden definiert.
	
	\section{Aufgabenliste}
	Die Gesamtheit der Aufgaben, die durch das Team zu erledigen sind, werden in der Aufgabenliste geführt. Alle Aufgaben werden als Ticket im System Redmine geführt. Die zu pflegenden Informationen jedes Tickets sind in Tabelle \ref{tab:tickets} dargestellt. 
	
	Für die Implementierung werden nur die User Stories als Tickets angelegt, die bereits im Bericht zum Meilenstein 1 vorgestellt wurden. Die weitere Verfeinerung der User Stories und die Ableitung der Aufgaben findet im GitHub Issue Tracker statt. Das heißt, dass die Implementierung nur sehr grob in Redmine abgebildet ist. Dieser Schnitt wird vollzogen, um den direkten Bezug der Implementierungsaufgaben zum Quellcode herstellen zu können. Da auch die Anzahl der in Redmine anfallenden Tickets deutlich reduziert wird, hilft dieses Vorgehen außerdem dabei, den Gesamtüberblick über das Projekt nicht zu verlieren.
	\begin{table}
		\centering
		\begin{tabularx}{\textwidth}{lX}
			\toprule
			\textbf{Aspekt} & \textbf{Beschreibung} \\
			\midrule
			Titel & Aussagekräftige Bezeichnung des Tickets \\
			ID & Für das Projekt eindeutige Identifikationsnummer \\
			Status & New / In Progress / Feedback / Closed \\
			Priorität & Low / Normal / High / Urgent \\
			Zugewiesen an & Die Person, die für die Bearbeitung des Tickets verantwortlich ist \\
			Übergeordnete Aufgabe & Jedes Ticket kann einem anderen Ticket untergeordnet werden. Hier wird das dann übergeordnete Ticket angegeben. \\
			Beginn und Abgabedatum & Falls erforderlich kann ein Beginn und Ende der Bearbeitung angegeben werden. \\
			Beschreibung & Hier wird das erforderliche Ergebnis beschrieben.\\
			\bottomrule
		\end{tabularx}
		\caption{Aufbau von Tickets im Redmine-System}
		\label{tab:tickets}
	\end{table}	
	
	\section{Sprint Backlog}
	Die Tickets, die im folgenden Sprint bearbeitet werden sollen, werden mit \textit{High} oder \textit{Urgent} priorisiert. Um ein Ticket als besonders dringend zu kennzeichnen, kann die höhere der beiden Priorisierungen genutzt werden, grundsätzlich wird hier jedoch die Priorität \textit{High} genutzt. Die Menge dieser Tickets bildet den Sprint Backlog, ein seperates Dokument wird nicht gepflegt. Der Lebenszyklus eines Tickets wird in Abbildung \ref{fig:ticketlebenszyklus} dargestellt. Während der Sprintplanung und während des Sprints werden die Tickets des Sprint Backlogs an die Teammitglieder zur Bearbeitung zugewiesen. Nach der Bearbeitung wird dem Team ein Ergebnisentwurf zur Verfügung gestellt wird. Das Team führt nun die festgelegten Qualitätssicherungsmaßnahmen durch, falls diese nicht bereits Bestandteil des vorherigen Bearbeitungsprozesses waren. Das Ergebnis wird anschließend freigegeben oder es werden Änderungen eingearbeitet. Die fertig bearbeiteten Tickets werden nicht gelöscht, sondern verbleiben als geschlossene Tickets in der Aufgabenliste.
	\begin{figure}
		\includegraphics[width=\textwidth]{Ticketlebenszyklus}
		\caption{Lebenszyklus eines Tickets}
		\label{fig:ticketlebenszyklus}
	\end{figure}
	
	
	\section{Ergebnisdokumentation}
	Das ausgelieferte Softwareprodukt wird in der Ergebnisdokumentation beschrieben. Nachfolgend werden die einzelnen Aspekte dieser Dokumentation vorgestellt.
	
	\subsection{Funktionsbeschreibung}
	Der in der Anwendung umgesetzte Geschäftsprozess wird aus der Sicht eines Nutzers mit der \textit{Business Process Model and Notation (\Gls{bpmn})} dargestellt. Es werden die unterstützten Fachfunktionen benannt und in den Gesamtkontext gebracht. Die wichtigsten Fachfunktionen werden detailliert beschrieben.
			
	\subsection{Softwarearchitektur}
	\label{subsec:softwarearchitektur}
	Die Softwarearchitektur wird aus verschiedenen Sichten beschrieben, in Tabelle \ref{tab:softwarearchitektur} sind diese dargestellt. Außerdem werden die zur Visualisierung zu nutzenden Modelle festgelegt.
	
	\begin{table}
		\centering
		\begin{tabularx}{\textwidth}{lXl}
			\toprule
			\textbf{Sicht} & \textbf{Beschreibung} & \textbf{Modell} \\
			\midrule
			Systemstruktur & Die Komponenten und die Schnittstellen der Anwendung werden in einem Überblick dargestellt. & \Gls{uml}-cod \\
			Daten & Das technische Datenmodell mit den Entitätstypen, den zugehörigen Attributen und den Beziehungen untereinander wird dargestellt.  & \Gls{uml}-cld \\
			\Gls{gui} & Die in der grafischen Benutzeroberfläche möglichen Zustände und die erlaubten Übergänge zwischen diesen werden dargestellt. Die visuelle Gestaltung der GUI (\zB in Form von grafischen Mockups) wird hier nicht dargestellt. & \Gls{uml}-sm\\
			Komponenten & Bei Bedarf werden einzelne Komponenten des Systems detaillierter dargestellt. & \Gls{uml}-cod \\
			Zeit & Bei Bedarf werden einzelne Aufrufbeziehungen zwischen Komponenten detailliert dargestellt. & \Gls{uml}-sqd \\
			\bottomrule
		\end{tabularx}
		\caption{Sichten und genutzte Modelle für die Dokumentation der Softwarearchitektur}
		\label{tab:softwarearchitektur}
	\end{table}	
	
	
	\subsection{Anhang}
	Tabelle \ref{tab:ergebnisdokumentation_anhang} stellt dar, welche weiteren Aspekte im Anhang aufgelistet werden.
	\begin{table}
		\centering
		\begin{tabularx}{\textwidth}{lX}
			\toprule
			\textbf{Aspekt} & \textbf{Beschreibung} \\
			\midrule
			Anforderungen & Die während des Projektzeitraums umgesetzten Anforderungen werden dargestellt. Zu jeder Anforderung wird der Erfüllungsgrad der Akzeptanzkriterien dargelegt. Nicht umgesetzte Anforderungen werden aufgelistet. \\
			Qualitätsziele & Die Erfüllung der Qualitätsziele und die durchgeführten Maßnahmen zur Qualitätssicherung werden zusammenfassend dargestellt. \\
			Benutzerhandbuch & Der Benutzer wird über die bestimmungsgemäße Nutzung der Anwendung informiert. Das Benutzerhandbuch wird in deutscher Sprache verfasst. \\
			Administration & Die Tätigkeiten zur Administration der Anwendung werden in einem Handbuch beschrieben. \\
			Inbetriebnahme & Die erforderlichen Schritte zur Installation und Inbetriebnahme werden beschrieben. \\
			\bottomrule
		\end{tabularx}
		\caption{Anhang der Ergebnisdokumentation}
		\label{tab:ergebnisdokumentation_anhang}
	\end{table}
	
	\section{Projektdokumentation}
	Eine Projektdokumentation informiert abschließend über den gesamten Verlauf des Projektes. Da zu diesem Projekt ein abschließender Projektbericht erstellt wird, beschränkt sich die hier zu erstellende Projektdokumentation auf die Darstellung des Entwicklungsfortschritts auf der Zeitachse. Dazu werden jeweils die Ergebnisse der Sprints zusammengefasst. Die Projektdokumentation soll dem Auftraggeber dazu dienen, die Arbeitsleistung des Projektteams \textit{ex post} bewerten zu können.
	 
	\section{Testprotokoll}
	\label{sec:testproto}
	Im Testprotokoll werden Rahmenbedingungen und Ergebnisse der durchgeführten Tests festgehalten.
	
	Es orientiert sich an folgender Struktur:
	\begin{itemize}
		\item Einleitung
		\item Testumgebung 
		\item Akzeptanzkriterien
		\item Testfälle und Ergebnisse
	\end{itemize}
	
	\section{Risiko-Wert-Matrix}
	\label{sec:risikowertmatrix} % Ist mir auch irgendwie nicht Projektspezifisch genug. Könnte man also ggf. weglassen.
	Die Bearbeitungsreihenfolge von Aufgaben im Projekt kann nicht willkürlich festgelegt werden. Einschränkend gibt es in nahezu jedem Fall Abhängigkeitsbeziehungen zwischen den Aufgaben. Auch andere Rahmenbedingungen können die Freiheitsgrade weiter einschränken. Die dann noch erforderliche Reihung der Aufgaben wird durch die Risiko-Wert-Matrix in Abbildung \ref{fig:risikowertmatrix} unterstützt. Mit Hilfe dieser Matrix wird zum Einen das \textit{Fail-Fast-Prinzip} umgesetzt. Demnach sollten Risiken möglichst frühzeitig angegangen werden. Ein Scheitern (engl. \textit{fail}) sollte somit möglichst zu einem frühen Zeitpunkt passieren, eben schnell (engl. \textit{fast}). Zum Anderen wird der Fokus auf wertbringende Aufgaben gelegt. Unter Berücksichtigung der Faktoren Risiko und Wert ergibt sich somit eine Umsetzungsreihenfolge.
	
	\begin{figure}
	\centering
	\renewcommand{\arraystretch}{2}	
	\begin{tabular}{rrccc}	
		\arrayrulecolor{white}
		& & &  \multicolumn{2}{c}{\textbf{Umsetzungsreihenfolge}} \\ 
		\multirow{2}{*}{\rotatebox{90}{\textbf{Risiko}}} &
		\cellcolor[HTML]{bee3d3}Hoch  && \cellcolor[HTML]{F6D8CE} Vermeiden & \cellcolor[HTML]{D8F6CE} Als Erstes umsetzen\\
		&\cellcolor[HTML]{bee3d3}Niedrig && \cellcolor[HTML]{F5ECCE}Zuletzt umsetzen & \cellcolor[HTML]{ECF6CE}Als Zweites umsetzen \\ \cmidrule[6pt]{3-4}
		&&& \cellcolor[HTML]{c2e0ae}Niedrig & \cellcolor[HTML]{c2e0ae}Hoch\\ 
		&&& \multicolumn{2}{c}	{\textbf{Wert}}
	\end{tabular}
	\caption{Risiko-Wert-Matrix}
	\label{fig:risikowertmatrix}
\end{figure}

	\newpage
	\chapter{Implementierung}
	Dieses Kapitel beschreibt die geplante Vorgehensweise und Rollenverteilung in Bezug auf den Implementierungsprozess. Daran anknüpfend werden die geplante Softwarearchitektur, die fachlichen Abläufe und das Datenmodell vorgestellt. Das Kapitel schließt mit einem Überblick über die eingesetzten Werkzeuge.
	
	\section{Implementierungsprozess}
	Wie der gesamte Softwareentwicklungsprozess wird auch die Implementierung agil durchgeführt. Die Definition der Rahmenbedingungen wurde bereits im Bericht zu Meilenstein 1 in Abschnitt 3.5 dargelegt.
	
	Im ersten Schritt der Implementierung wird die Grobstruktur des Systems erarbeitet. Die Reihenfolge der zu erstellenden Softwareartefakte ergibt sich einerseits durch die strukturellen Abhängigkeitsbeziehungen. Damit ist \zB die Abhängigkeit des Backends von den im Frontend gewonnen Daten gemeint.\footnote{Auf die Erstellung von Dummies oder Treibern wird in diesem Projekt verzichtet.} Andererseits ergeben sich durch den fachlichen Prozess zeitliche Abhängigkeiten. Dem bezüglich der Implementierungsreihenfolge übrigen Entscheidungsspielraum wird mit der Risiko-Wert-Matrix (siehe Abschnitt \ref{sec:risikowertmatrix}) begegnet.
	
	\subsection{Vorgehensmodell}
	
	Die Implementierung des Projekts erfolgt angelehnt an \textit{Scrum} in Sprint-Zyklen. Detaillierte Ausführungen zu Ablauf und Ausgestaltung der Sprints finden sich im Bericht zu Meilenstein 1 in Abschnitt 3.5.3. 
	
	\subsection{Rollenverteilung}
	Die Rollenverteilung während der Implementierung ergibt sich ebenfalls aus den Festlegungen, die im Bericht zu Meilenstein 1 getroffen wurden. Diese Zuordnung ist allerdings nicht trennscharf, denn zwischen den Themenbereichen gibt es Überschneidungen und Verknüpfungen. 
	
	An dieser Stelle werden kurz die Tätigkeitsschwerpunkte der Mitglieder des Projektteams in Bezug auf den Implementierungsprozess dargestellt.
	
	\subsubsection{Jörg Sawatzki}
	Jörg überwacht als \textit{Head of Development} den Entwicklungsprozess und sichert das reibungslose Zusammenspiel der Architekturkomponenten. Er unterstützt bei der Programmierung des Frontends und des Backends.
	
	\subsubsection{Daniel Moch}
	Daniel hat bereits Erfahrungen mit JavaScript und unterstützt bei der Frontend-Entwicklung und bei den parallel zur Entwicklung laufenden Integrationstests.
	
	\subsubsection{Maximilian Hahn}
	Maximilian hat bereits Erfahrungen mit der Programmiersprache Python und unterstützt dementsprechend bei der Backend-Entwicklung und dem Test der Schnittstelle.
	
	\subsubsection{Holger Lapenat}
	Holger bringt als Fachinformatiker für Systemintegration fundierte Erfahrungen im Betrieb von Serversystemen mit. Er sorgt für die Installation und Wartung des Entwicklungsservers und führt regelmäßige Deployments durch. Außerdem unterstützt er beim kontinuierlichen Test der Artefakte und überwacht Akzeptanzkriterien.

	
	\section{Architektur}
	\label{sec:architektur}
		Q-Teams wird als \textit{Single Page Application (SPA)} umgesetzt, d. h. die grafische Oberfläche der Applikation wird komplett im Webbrowser gerendert (Frontend). Die Kommunikation mit dem zentralen Server (Backend) erfolgt über eine Web-Schnittstelle.
		
		Im Folgenden wird die Architektur der zentralen Komponenten beschrieben.
		
	\subsection{Backend}
	\label{subsec:backend}
	Das serverseitige Backend übernimmt die Datenhaltung sowie die fachliche Anwendungslogik und stellt die Schnittstelle zum Frontend bereit. Es wird in der Programmiersprache Python mit dem Django-Framework\footnote{https://www.djangoproject.com/} implementiert. Django ist ein auf einer \frqq{}Model View Controller (MVC)\flqq{}-Architektur basierendes Framework für datenbankgestützte Web-Applikationen.
	
	Das Django-Framework abstrahiert über einen Object Relational Mapper (ORM) den Datenbankzugriff, so dass verschiedene relationale Datenbanken ohne Anpassung des Programmcodes verwendet werden können. Da es sich bei diesem Projekt lediglich um einen Prototyp handelt, wird das SQLite-Backend gewählt. SQLite ist ein dateibasiertes Datenbanksystem, das ohne einen Datenbankserver auskommt und sich deshalb schnell und unkompliziert integrieren lässt.
	
	Zur Anbindung des Frontends stellt der Server eine GraphQL-Schnittstelle bereit. GraphQL\footnote{https://graphql.org/} ist eine von Facebook entwickelte schemabasierte Abfragesprache. Im Gegensatz zu klassischen REST-APIs erlaubt GraphQL dem Client genau festzulegen, welche Datenfelder und -beziehungen vom Server zurück geliefert werden, so dass das Entwerfen benutzerdefinierter Query-Parameter nicht mehr nötig ist. Darüber hinaus wird mithilfe des GraphQL-Schemas bereits auf dem Client verhindert, dass fehlerhafte Anfragen formuliert werden können.
	
	GraphQL ermöglicht es mit \textit{Subscriptions} einem Client, sich über Ereignisee benachrichtigen zu lassen. Dieser Mechanismus ist mit den von mobilen Geräten bekannten Push-Benachrichtigungen vergleichbar. Q-Teams verwendet Subscriptions, um den Spielablauf auf den Clients aller beteiligten Spieler zu synchronisieren. Technisch realisiert wird dies über eine WebSocket-Verbindung.

	Der Backend-Server stellt außerdem eine serverseitig gerenderte Web-Oberfläche zur Administration der Q-Teams-Instanz bereit. Diese basiert auf der angepassten Django-Administrationsoberfläche.
	
	\subsection{Frontend}
	Das Frontend stellt die grafische Oberfläche dar, mit der die Spieler interagieren. Sie wird im Webbrowser ausgeführt und wird dementsprechend in der Programmiersprache JavaScript implementiert.
	
	 Für die Umsetzung der \Gls{gui}-Komponenten kommt das React-Framework\footnote{https://reactjs.com} zum Einsatz. React ist ein von Facebook veröffentlichtes, deklaratives und komponentenorientiertes Framework zur schnellen Entwicklung von clientseitig gerenderten Benutzerschnittstellen.
	
	Details zur Anbindung an das Backend wurden bereits im Abschnitt \ref{subsec:backend} beschrieben.

	\section{Prozessbeschreibung}
	\label{sec:process}
	
	Abbildung \ref{fig:bpmn} auf Seite \pageref{fig:bpmn} visualisiert den zu implementierenden Spielablauf mithilfe eines BPMN-Diagramms. Das Diagramm zeigt den Prozess für einen Spieler und die Interaktionen mit den anderen Spielern des Q-Teams. Der Prozess der anderen Spieler wird hier lediglich als Black-Box gezeigt (Pool \textit{TEAM} auf der linken Seite), da die Prozesse identisch sind. Die Kommunikation zwischen den Spielern geschieht ausschließlich mittels Nachrichten, mit denen Datenobjekte assoziert sein können.
	
	Wie bereits im Lösungsansatz\footnote{Abschnitt 3.2 im Bericht zum Meilenstein 1} beschrieben, hat jede Spielrunde sechs Phasen, die im Diagramm als Gruppen dargestellt sind. Es gibt drei Datenspeicher, die mindestens für die Dauer einer Runde bestehen: der \textit{Katalog der Runde} (grün), die \textit{Statistik} (blau) und die \textit{Knowledge Base} (grau).
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{bpmn.png}
		\caption{Prozessbeschreibung des Spielablaufs}
		\label{fig:bpmn}
	\end{figure}	 

	
	\subsection{Beginn des Spiels}
	\label{subsec:beginndesspiels}
	Der Spieler startet sein Spiel in der Phase \textit{Beginn des Spiels}. Entweder gründet der Spieler ein Q-Team und benachrichtigt die anderen Spieler darüber, oder er wird von einem anderen Spieler benachrichtigt und tritt einem Q-Team bei. 
	Die Ausgestaltung der beiden genannten Aktivitäten ist für den Gesamtablauf nicht relevant. Sind alle Spieler dem Q-Team beigetreten und haben ihre Bereitschaft signalisiert, geht das Spiel in die nächste Phase über. Hier ist auch der Einstiegspunkt für eine weitere Runde (siehe Abschnitt \nameref{subsec:schlussphase}).
	
	\subsection{Erarbeitungsphase}
	\label{subsec:erarbeitungsphase}
	In der Erarbeitungsphase erstellt jeder Spieler eine Frage und die dazugehörige Musterantwort. Die Knowledge Base, \dash die Gesamtheit der bisher gespeicherten Fragen und Musterantworten, kann bei dieser Aktivität als Inspiration genutzt werden. Die durch den Spieler erstellte Frage und Antwort werden in der Knowledge Base und im Katalog der Runde gespeichert. Haben dies alle Spieler abgeschlossen, wird der nächste \nameref{subsec:phasenuebergang} geprüft.
	
	\subsection{Phasenübergang}
	\label{subsec:phasenuebergang}
	Aus der \nameref{subsec:erarbeitungsphase} oder der \nameref{subsec:klaerungsphase} kommend, wird geprüft, ob noch Fragen im Katalog der Runde vorhanden sind, die bisher noch nicht an das Q-Team gestellt wurden. Ist dies der Fall, geht das Spiel in die \nameref{subsec:fragephase} über, sonst geht das Spiel in die \nameref{subsec:schlussphase} über.
	
	\subsection{Fragephase}
	\label{subsec:fragephase}
	In der Fragephase wird aus dem Katalog der Runde eine Frage zufällig gewählt, die dem Q-Team gestellt wird. Jede Frage wird nur einmal gestellt. Ist der Spieler der Fragesteller der gewählten Frage, geht das Spiel in die \nameref{subsec:bewertungsphase} über. Wurde die Frage nicht vom Spieler erstellt, beantwortet er diese und sendet die Antwort an den Fragesteller und speichert sie im Katalog der Runde. Dann geht das Spiel in die \nameref{subsec:bewertungsphase} über.
	
	\subsection{Bewertungsphase}
	\label{subsec:bewertungsphase}
	Als Fragesteller hat der Spieler die Antworten der anderen Spieler zu bewerten. Diese Aktivität findet sequentiell mehrfach statt. Der Spieler empfängt die Antwort eines Spielers und bewertet diese in den Stufen
	\begin{itemize}
	\item richtig (3 Punkte),
	\item teilweise richtig (1 Punkt) oder
	\item falsch (0 Punkte).
	\end{itemize}
	Die Bewertung sendet er an den entsprechenden Spieler und speichert sie außerdem in der Statistik ab.
	
	Hat der Spieler hingegen die Frage beantwortet, erhält er aus dem Katalog der Runde die Musterantwort und die Antworten der anderen Spieler zur Auswertung. Hat der Fragesteller die Antwort bewertet, erhält der Spieler auch die Bewertung.
	
	Wurden alle Antworten durch den Fragesteller bewertet, geht das Spiel in die \nameref{subsec:klaerungsphase} über.
	
	\subsection{Klärungsphase}
	\label{subsec:klaerungsphase}
	Die Antworten und Bewertungen werden zwischem dem Spieler und dem Rest des Q-Teams geklärt. Ist das Q-Team wieder bereit wird der nächste \nameref{subsec:phasenuebergang} geprüft.
	
	\subsection{Schlussphase}
	\label{subsec:schlussphase}
	In der Schlussphase kann der Spieler noch einmal alle Fragen und Antworten aus dem Katalog der Runde  und seine persönliche Statistik auswerten. Im Wettkampfmodus kann der Spieler auch die Statistik der anderen Spieler des Q-Teams auswerten.
	
	Das Q-Team kann sich nun entschließen, eine weitere Runde zu spielen. Das Spiel startet dann am Ende der Phase \textit{\nameref{subsec:beginndesspiels}}. Ansonsten endet das Spiel an dieser Stelle.
	 
	
	\section{Datenmodell}
	
	Das geplante Datenmodell ist in Abbildung \ref{fig:models} in Form eines Klassendiagramms dargestellt, dessen Elemente im Folgenden kurz erläutert werden. Es handelt sich dabei um eine aus dem Python-Code generierte grafische Repräsentation des Datenmodells, die allerdings nicht den UML-Standard erfüllt.
	
	Jedes Rechteck entspricht dabei einer Klasse, deren Name in der grün hinterlegten Kopfzeile angegeben ist. Unmittelbar darunter sind Attributnamen und -typen angegeben. In Fettschrift sind Attribute dargestellt, die als Schlüssel dienen. In grauer Farbe gedruckt sind optionale Attribute bzw. Attribute, die vom System automatisch gesetzt werden. Die Attribute \textit{created\_{}at} und \textit{updated\_{}at} werden vom System automatisch mit dem Zeitstempel der Erstellung bzw. der letzten Änderung des Objektes versehen.
	
	Die Bögen, die einzelne Klassen untereinander verbinden, stellen die Beziehungen zwischen den Entitäten dar. Ist ein Bogen nur an einem Ende mit einem großen schwarzen Punkt versehen, so handelt es sich um eine \textit{1:n}-Beziehung. Enthält der Bogen an beiden Ende große schwarze Punkte, so symbolisiert dies eine \textit{n:m}-Beziehung der Klassen. Die Beschriftung der Bögen enthält zuerst den Attributnamen, über den von der die Beziehung definierenden Klasse auf die andere Klasse zugriffen werden kann. Danach folgt in runden Klammern der Attributname auf Seiten der anderen Klasse.
	
	1:n-Beziehungen sind über Fremdschlüssel \textit{(foreign keys)} realisiert, während n:m-Beziehungen zusätzliche Datenbanktabellen benötigen, die an dieser Stelle aus Gründen der Übersichtlichkeit nicht dargestellt werden.
	
	Das \textit{User}-Modell repräsentiert einem Benutzer des Systems und wird vom eingebauten Authentifizierungssystem des Django-Frameworks bereitgestellt. Für weitere Details dazu sei auf die Dokumentation\footnote{https://docs.djangoproject.com/en/3.0/ref/contrib/auth/} verwiesen.
	
	Nachfolgend werden die wichtigsten Aspekte der im Diagramm dargestellten Entitäten vorgestellt.
	
	\subsection{Team}
	Die Klasse \textit{Team} ist das Herzstück der Quiz-App. Sie bildet ein Team von Benutzern ab, die zusammen spielen (\textit{members}). Außerdem speichert sie den Benutzer, der das Team erstellt hat (\textit{creator}), enthält einen frei wählbaren Namen (\textit{name}) und wird einem Thema (\textit{topic}) zugeordnet.
	
	Das Feld für den Spielmodus (\textit{mode}) kann die Werte \texttt{train} (Trainingsmodus) oder \texttt{competition} (Wettkampf) annehmen.
	
	Ein Team befindet sich immer in einem definierten Zustand (\textit{state}):
	
	\begin{itemize}
		\item \texttt{open}: Das Team wurde erstellt und kann noch Mitglieder aufnehmen.
		\item \texttt{playing}: Das Spiel wurde gestartet. Ein Hinzufügen weiterer Mitglieder ist nicht mehr möglich.
		\item \texttt{archived}: Das Spiel wurde beendet und das Team ist archiviert.
	\end{itemize}
	
	\subsection{Round}
	Die Klasse \textit{Round} bildet eine Spielrunde ab. 
	
	Die Runde kann sich in folgenden Phasen befinden: 
	
	\begin{itemize}
		\item \texttt{question}: Diese Phase stellt die \textit{Erarbeitungsphase} dar. In dieser Phase erarbeiten die Teammitglieder fachliche Fragen für ihre Mitspieler. 
		\item \texttt{answer}: In dieser Phase müssen die Spieler die erarbeiteten Fragen beantworten. Das System wählt die jeweils zu bearbeitende Frage zufällig aus und hinterlegt sie im Feld \textit{current\_{}question}.
		\item \texttt{scoring}: Bei Eintritt in die \textit{Bewertungsphase} haben die Spieler ihre Antworten eingegeben und es erfolgt die Bewertung durch den Fragesteller. Sind noch unbeantwortete Fragen in der Runde vorhanden, so wechselt die Runde wieder in den Zustand \texttt{answer}.
		
		\item \texttt{done}: Diese Phase markiert den Abschluss der Runde. Spielern wird abhängig vom gewählten Spielmodus nur eine persönliche oder eine gesamte Statistik der Leistung des Teams angezeigt. 
	\end{itemize}
	
	\subsection{Question}
	Die Klasse \textit{Question} bildet eine fachliche Frage ab. Sie speichert den Autor (\textit{author}) der Frage, den Fragetext (\textit{question}), das zugehörige Thema (\textit{topic}) und die Musterantwort (\textit{model\_{}answer}. Fragen können nur in einer Runde (\textit{round}) verwendet werden. Übernehmen Spieler eine Frage aus der \textit{Knowledge Base}, so wird eine Kopie erstellt, die vom Nutzer angepasst werden kann.
	
	\subsection{Answer}
	Die Klasse \textit{Answer} enthält die Antwort (\textit{answer}) eines Spielers (\textit{author}) auf eine Frage (\textit{question}). Sie speichert außerdem die durch den Fragesteller vergebene Bewertung (\textit{score}).
	
	\subsection{Topic}
	Die Klasse \textit{Topic} stellt ein fachliches Thema dar. Hier könnte beispielsweise eine Liste der an der IUBH verfügbaren Module hinterlegt werden. Diese Klasse dient lediglich der besseren Strukturierung der Fragen in der \textit{Knowledge Base}.
	
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{models.png}
		\caption{Fachliche Entitäten im Klassendiagramm}
		\label{fig:models}
	\end{figure}
	
	\section{Werkzeuge}
	Im Folgenden werden die im Rahmen der Implementierung genutzten Werkzeuge kurz vorgestellt.
	
	\subsection{Visual Studio Code}
	\textit{Visual Studio Code}\footnote{https://code.visualstudio.com/} ist einheitliche Entwicklungsumgebung für Frontend und Backend.
	
	\subsection{Git}
	\textit{Git}\footnote{https://git-scm.com/} wird als Versionskontrollsystem zur Verwaltung des Quellcodes eingesetzt.
	
	\subsection{NPM}
	Der \textit{Node Package Manager (NPM)}\footnote{https://www.npmjs.com/} wird zur Verwaltung der im Frontend benötigten externen JavaScript-Bibliotheken eingesetzt.
	
	\subsection{Pip}
	Das Tool \textit{Pip}\footnote{https://packaging.python.org/guides/tool-recommendations/} verwaltet die vom Backend benötigten externen Python-Bibliotheken.
	
	\subsection{Webpack}
	\textit{Webpack}\footnote{https://webpack.js.org/} minimiert und bündelt den CSS- und JavaScript-Code des Frontends für die Ausführung im Browser.
	

	\chapter{Qualitätsmanagement}
	
	\section{Qualitätsziele}
	Im Folgenden werden die für das Projekt festgelegten Qualitätsziele anhand der in der Norm\linebreak ISO/IEC~9126 beschriebenen sechs Qualitätskriterien skizziert.
	
	Die formulierten Qualitätsziele dienen zunächst als grobe Handlungsmaxime bei der Entwicklung einzelner Artefakte und werden bei Bedarf verfeinert.
	
	\subsection{Funktionalität}
	
	\begin{itemize}
		\item Die Quiz-App soll den im Abschnitt \ref{sec:process} dargestellten fachlichen Prozess korrekt abbilden.
		\item Das System soll gegenüber Bedrohungen von innen und außen gesichert sein (siehe Abschnitt~\ref{sec:itsicherheit}).		
	\end{itemize}
	
	\subsection{Benutzbarkeit}
	\begin{itemize}
		\item Die Bedienung des Systems soll leicht erlernbar und möglichst intuitiv verständlich sein.
		\item Die Oberfläche soll simpel und ansprechend gestaltet sein.
	\end{itemize}
	
	\subsection{Änderbarkeit}
	\begin{itemize}
		\item Der Prototyp soll einfach erweiterbar sein und zu einem späteren Zeitpunkt zu einem ausgereiften Produkt ausgebaut werden können.
		\item Die Grundfunktionen des Systems sollen einfach getestet werden können.
	\end{itemize}
	
	\subsection{Effizienz}
	\begin{itemize}
		\item Mit Serverressourcen soll schonend umgegangen werden.
		\item Da es sich um eine interaktive Anwendung handelt, sollten Antwortzeiten des Systems niedrig gehalten werden.
	\end{itemize}
	
	\subsection{Übertragbarkeit}
	\begin{itemize}
		\item Das System soll einfach und unkompliziert bei einem Hosting-Provider installiert werden können.
		\item Das System soll einfach in die Anwendungslandschaft einer Hochschule integrierbar sein.
\end{itemize}		

	\subsection{Zuverlässigkeit}
	\begin{itemize}
		\item Das System wird lediglich prototypisch umgesetzt, daher ist nur ein geringer Reifegrad gefordert.
		\item Das System soll fehlerhafte Eingaben abfangen können.
	\end{itemize}
	
	\section{IT-Sicherheit}
	\label{sec:itsicherheit}
	
	Da es sich bei der zu entwickelnden App lediglich um einen Prototyp handelt, soll kein umfassendes Konzept zur IT-Sicherheit, wie es \zB das Bundesamt für Sicherheit in der Informationstechnik (BSI) mit dem IT-Grundschutz-Framework vorschlägt, umgesetzt werden.
	
	Im Folgenden werden die für dieses Projekt im Rahmen einer prototypischen Umsetzung relevanten Sicherheitsaspekte beschrieben.
	
	\subsection{Verschlüsselte Verbindungen}
	Alle Verbindungen zwischen Endnutzern (Spielern, Administratoren) und dem System sollen mithilfe von SSL/TLS verschlüsselt werden.
	

	\subsection{Speicherung von Passwörtern}
	Passwörter von Nutzern der Anwendung werden ausschließlich verschlüsselt in der Datenbank hinterlegt.
	
	\subsection{Sicherheitsrichtlinien für Passwörter}
	 Das Passwort darf nicht zu ähnlich zu anderen persönlichen Informationen (Vorname, Nachname, E-Mail, Benutzername) sein.
    Das Passwort muss mindestens 8 Zeichen enthalten.
    Das Passwort darf nicht komplett aus Ziffern bestehen.	
    
    \subsection{Kapselung der Datenbankzugriffe}
    Um Angriffe auf das Datenbanksystem \zB in Form von \textit{SQL-Injections} zu verhindern, soll der Zugriff auf die Datenbank nur über den entsprechend gekapselten \textit{Object Relational Mapper (ORM)} erfolgen.
	
	\subsection{Zugang zum Server}
	Der Wartungszugang zum Server soll ausschließlich verschlüsselt über das SSH-Protokoll erfolgen. Zur Authentifizierung sollen ausschließlich RSA-Schlüssel verwendet werden können.
	
	\subsection{Prinzip der geringsten Privilegien}
	Das System soll so gestaltet werden, dass jeder Nutzer nur genau so viele Privilegien erhält, wie er für seine Arbeit mit dem System benötigt.
	
	\section{Konstruktives Qualitätsmanagement}
	Das konstruktive Qualitätsmanagement setzt sich aus organisatorischen, technischen und zwischenmenschlichen Maßnahmen zusammen, die im Folgenden erläutert werden.
	
	\subsection{Organisatorische Maßnahmen}
	\begin{itemize}
		\item Mit dem in diesem Bericht dargestellten Dokumentationskonzept existiert ein Template für die zu erstellenden Dokumentationsartefakte.
		\item Die im Abschnitt \ref{sec:architektur} detaillierte Architektur dient als verbindliche Richtlinie für die Entwickler.
	\end{itemize}		
	
	\subsection{Technische Maßnahmen}
	\begin{itemize}
		\item User Stories sind zentrales Tool zur Verwaltung der Anforderungen.
		\item Zur Priorisierung von Aufgaben werden nach Bedarf die Risiko-Wert-Matrix oder die MoSCoW-Methode eingesetzt. 
		\item Alle Entwickler benutzen mit Visual Studio Code dieselbe Entwicklungsumgebung.
		\item Modellierungssprachen (\Gls{uml}, \Gls{bpmn}) werden verbindlich festgelegt.
		\item Mit Python (Backend) und JavaScript (Frontend) werden die eingesetzten Programmiersprachen vorgegeben.
		\item Git wird als zentrales Werkzeug zur Quellcode-Verwaltung vorgegeben.
		\item Redmine ist verbindliches Projektmanagement-Tool.
	\end{itemize}
	
	\subsection{Zwischenmenschliche Maßnahmen}
	\begin{itemize}
		\item Es findet regelmäßige und intensive Kommunikation statt.
		\item Mithilfe von \textit{Pair Programming} unterstützen sich die Teammitglieder gegenseitig.
	\end{itemize}		
	
\section{Review-Verfahren}	
Ein Review ist ein statisches manuelles Prüfverfahren zur Analyse eines Prüflings. In diesem Projekt werden zentrale Ergebnisartefakte teamintern gereviewt. Die Entscheidung darüber ob und wie ein Artefakt gereviewt wird, bestimmt sich in erster Linie danach, wie groß der Einfluss des Artefakts auf die weitere Softwareentwicklung ist. Für Artefakte, die ein Teil des auszuliefernden Softwareproduktes sind, ist hier der Wertanteil dieses Artefakts am Gesamtprodukt entscheidend. Dies soll an einem Beispiel verdeutlicht werden: Der fachliche Prozess steht am Anfang der Softwareentwicklung. Er ist maßgeblicher Anforderungsträger an das zu entwickelnde Produkt. Hier ist es wichtig, dass alle Teammitglieder ein gemeinsames Verständnis von diesem Prozess haben und alle ihre jeweiligen Erfahrung und ihr Wissen eingebracht haben, um die Qualität des Prozesses sicherzustellen. Ein gründlicher Review der Prozessbeschreibung ist also erforderlich, wie sich später zeigen wird, ist in diesem Fall ein Walkthrough durchzuführen. 

Typische Review-Techniken sind die Stellungnahme, der Walkthrough und die Inspektion. Unter Berücksichtigung der Rahmenbedingungen dieses Projekts ist eine Inspektion nicht gerechtfertigt und wird deshalb nicht durchgeführt. Je nach Ausprägung der oben geschilderten Entscheidungsfaktoren entscheidet das Team also, ob eine Stellungnahme oder ein Walkthrough durchgeführt wird.

\subsection{Stellungnahme}
Abbildung \ref{fig:stellungnahme} visualisiert den Prozess einer Stellungnahme. 
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{stellungnahme.png}
		\caption{Ablauf einer Stellungnahme}
		\label{fig:stellungnahme}
	\end{figure}
Zunächst wählt der Autor einen Gutachter. In diesem Projekt wird grundsätzlich nur durch einen Gutachter geprüft. Die Aufgabenschwerpunkte, die jedem Teammitglied im Bericht zu Meilenstein 1 zugewiesen wurden, entscheiden dabei über den jeweiligen Gutachter, denn es finden sich zu den meisten Themengebieten zwei Teammitglieder. Zusammen mit dem Gutachter konfiguriert der Autor den Review, \dash sie stimmen sich über den Umfang, die Dauer und den Schwerpunkt des Reviews ab. Der Gutachter führt daraufhin die individuelle Begutachtung des Prüflings durch. Danach werden die Fragen zum Prüfling und die identifizierten Mängel gemeinsam diskutiert. Hiermit endet der Prozess für den Gutachter. Der Autor überarbeitet noch den Prüfling und der Review-Prozess ist abgeschlossen. Eine Dokumentation über die Stellungnahme findet in diesem Projekt nicht statt.

\subsection{Walkthrough}
Abbildung \ref{fig:walkthrough} stellt den Ablauf eines Walkthroughs dar.
	\begin{figure}
		\centering
		\includegraphics[width=\textwidth]{walkthrough.png}
		\caption{Ablauf eines Walkthroughs}
		\label{fig:walkthrough}
	\end{figure}
Das Team entscheidet über die Durchführung eines Walkthroughs bei einem Artefakt. Teilnehmer sind der Autor, der gleichzeitig als Moderator fungiert, und alle anderen Teammitglieder. Die anderen Teammitglieder sind die Gutachter, die den Prüfling begutachten. Nach der Entscheidung für einen Walkthrough konfiguriert der Autor den Review. Dabei stimmt er den Termin mit dem Team ab und legt die Prüfziele fest. Sind bereits Akzeptanzkriterien festgelegt, werden diese genutzt. Die Prüfziele und der Prüfling werden an die Teammitglieder übermittelt. Daraufhin arbeitet jeder Gutachter individuell den Prüfling durch und dokumentiert für sich Fragen und identifizierte Mängel. In der Review-Sitzung wird der Prüfling dann gemeinsam durchgearbeitet und alle Fragen und Mängel werden diskutiert. Der Autor überarbeitet zuletzt den Prüfling und der Review-Prozess ist abgeschlossen. Ein Review-Bericht wird grundsätzlich nicht angefertigt.
	
\section{Testfallerstellung}
	Aufgrund der begrenzten zeitlichen und personellen Ressourcen und dem prototypischen Charakter des Projektes soll mit nur wenigen Testfällen versucht werden, eine möglichst weitreichende Testabdeckung der wesentlichen fachlichen Funktionen zu erreichen.
	
	Es wird die Methode der anwendungsfallbasierten Testfallerstellung gewählt. Dabei werden aus dem Diagramm zur Prozessbeschreibung (Abbildung \ref{fig:bpmn}) und den User Stories Testfälle abgeleitet und implementiert. 
	
	Da automatisierte GUI-Tests einen hohen Entwicklungsaufwand mit sich bringen, soll das Frontend größtenteils manuell getestet werden. Der Fokus im Kontext des automatisierten Testens liegt dementsprechend auf den Schnittstellen und Modulen des Backends. 
	
	Testfälle und Ergebnisse werden im Testprotokoll dokumentiert (siehe Abschnitt \ref{sec:testproto}).
	
	\printglossaries
	\newpage	
	\printbibliography[heading=bibnumbered,title=Literaturverzeichnis]

\end{document}
